name: build_docker_images
on: push

jobs:
  main-job:
    name: Build docker images
    runs-on: ubuntu-latest

    # We build images from the container to access postgres (to apply migrations)
    container: docker/compose

    services:
      postgres:
        image: postgres:13.4-alpine3.14
        env:
          POSTGRES_USER: admin
          POSTGRES_PASSWORD: admin
          POSTGRES_DB: notepad
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          # We expose port on the host to be able to access postgres from image builder.
          # And we can use container port without exposing it on the host
          # if we just want to use postgres in workflow, not in builder (here - apply migrrations)
          - 5431:5432

    steps:
      - name: Install postgresql-client
        # docker/compose doesn't have postgresql client by default
        run: apk add --no-cache postgresql-client

      - name: Install tar
        # docker/compose ships with a very limited version of tar, which is incompatible with actions/cache
        run: apk add --no-cache tar

      - uses: actions/checkout@v2

      - name: Stack cache
        # Stack dependencies are compressed and copied from the build container.
        # See Dockerfiles for the details
        uses: actions/cache@v2
        with:
          path: backend/cache
          key: notepad.stack_dependencies
          restore-keys: notepad.stack_dependencies

      - name: Apply migrations
        # postgresql-typed checks the backend against the database at compile time.
        # We needf database schema to be exactly the same as in production, but we don't need the data.
        # That's why applying migrations is enough.
        run: export PGPASSWORD=admin; psql -h postgres -p 5432 -U admin -d notepad -f postgres/1.init.sql

      - name: Build backend image
        run: |
          docker_host_ip=$(ip route show | awk '/default/ {print $3}') docker-compose -f dc.prod-github-actions.yml build backend-artifacts

            # Create container from image without running it to extract artifacts
          id=$(docker create notepad_backend-artifacts)

            # Save stack depenencies cache
          docker cp $id:/root/stack_dependencies_cache.tar.gz - > ./backend/cache/stack_dependencies_cache.tar.gz.tar

            # Replace the existing generated code with just generated
            # Note: we could also do it via docker, 
            # but it will require anyone to build backend-artifacts before building the frontend
            # which will take 20-40 minutes.
          rm -rf frontend/src/Api
          docker cp $id:/frontend/src/Api - > frontend/src/Api.tar
          tar -xf frontend/src/Api.tar -C frontend/src
          rm frontend/src/Api.tar

            # Remove the container after extracting artifacts
          docker rm -v $id

          docker-compose -f dc.prod-local.yml build backend
          # TODO: docker-compose -f dc.prod-github-actions.yml push backend

      - name: Build frontend image
        run: |
          docker-compose -f dc.prod-github-actions.yml build frontend
          # TODO: docker-compose -f dc.prod-github-actions.yml push frontend
